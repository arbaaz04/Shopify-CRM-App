{"version":3,"sources":["../effects.ts"],"sourceRoot":"","sourcesContent":["import type { FilterElement, GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport path from \"path\";\nimport { validateBelongsToLink } from \"../auth\";\nimport { getActionContextFromLocalStorage, getCurrentContext, getModelByApiIdentifier, internalModelManagerForModel } from \"../effects\";\nimport { InvalidActionInputError } from \"../errors\";\nimport { Globals, kGlobals } from \"../globals\";\nimport { AppTenancyKey } from \"../tenancy\";\nimport type { AnyParams } from \"../types\";\nimport { assert } from \"../utils\";\nimport { invalidPlanDisplayNames, invalidPlanNames } from \"./constants\";\n\nexport const ShopifyShopState = {\n  Installed: { created: \"installed\" },\n  Uninstalled: { created: \"uninstalled\" },\n};\n\nexport const ShopifySyncState = {\n  Created: \"created\",\n  Running: \"running\",\n  Completed: \"completed\",\n  Errored: \"errored\",\n};\n\nexport const ShopifyBulkOperationState = {\n  Created: \"created\",\n  Completed: \"completed\",\n  Canceled: \"canceled\",\n  Failed: \"failed\",\n  Expired: \"expired\",\n};\n\nexport const ShopifySellingPlanGroupProductVariantState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\nexport const ShopifySellingPlanGroupProductState = {\n  Started: \"started\",\n  Created: \"created\",\n  Deleted: \"deleted\",\n};\n\n/**\n * The following is used to power shopifySync model.\n * Learn more about syncing visit our docs: https://docs.gadget.dev/guides/plugins/shopify/syncing-shopify-data#syncing\n */\nexport async function shopifySync(params: AnyParams, record: GadgetRecord<any>): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: {\n    syncSince?: Date;\n    syncSinceBy?: string;\n    id: bigint;\n    shopId: string;\n    models: any;\n    force: boolean;\n    syncLast?: number;\n    syncLastBy?: string;\n  } = assert(record, \"cannot start a shop sync from this action\");\n\n  const shopId = assert(syncRecord.shopId, \"a shop is required to start a sync\");\n\n  if (syncRecord.syncSinceBy && syncRecord.syncSinceBy !== \"created_at\" && syncRecord.syncSinceBy !== \"updated_at\") {\n    throw new InvalidActionInputError(\"syncSinceBy must be either 'created_at' or 'updated_at'\");\n  }\n  if (syncRecord.syncLastBy && syncRecord.syncLastBy !== \"created_at\" && syncRecord.syncLastBy !== \"updated_at\") {\n    throw new InvalidActionInputError(\"syncLastBy must be either 'created_at' or 'updated_at'\");\n  }\n  if (!syncRecord.models || (Array.isArray(syncRecord.models) && syncRecord.models.every((m) => typeof m == \"string\"))) {\n    try {\n      await effectAPIs.sync(\n        syncRecord.id.toString(),\n        shopId,\n        syncRecord.syncSince,\n        syncRecord.models,\n        syncRecord.force,\n        params.startReason,\n        syncRecord.syncSinceBy,\n        syncRecord.syncLast,\n        syncRecord.syncLastBy\n      );\n    } catch (error) {\n      context.logger.error({ error, connectionSyncId: syncRecord.id }, \"an error occurred starting shop sync\");\n      throw error;\n    }\n  } else {\n    throw new InvalidActionInputError(\"Models must be an array of api identifiers\");\n  }\n}\n\nexport async function abortSync(params: AnyParams, record: GadgetRecord<any>): Promise<void> {\n  const context = getActionContextFromLocalStorage();\n  const effectAPIs = context.effectAPIs;\n\n  const syncRecord: { id: bigint } = assert(record, \"a record is required to abort a shop sync\");\n\n  const syncId = assert(syncRecord.id, \"a sync id is required to start a sync\");\n\n  if (!params.errorMessage) {\n    record.errorMessage = \"Sync aborted\";\n  }\n\n  context.logger.info({ userVisible: true, connectionSyncId: syncId }, \"aborting sync\");\n\n  try {\n    await effectAPIs.abortSync(syncId.toString());\n  } catch (error) {\n    context.logger.error({ error, connectionSyncId: syncId }, \"an error occurred aborting sync\");\n    throw error;\n  }\n}\n\n/**\n * Applicable for multi-tenant Shopify apps(public apps), or Shopify Customer Extension apps\n * Enforces that the given record is only accessible by the current shop or customer\n *\n * For new records: sets the the current session's `shopId` to the record. If the tenant is a customer then will set the current sessions' customerId to the record.\n * For existing records: Verifies the record objects `shopId` and/or `customerId` matches the one from the current session.\n *\n * *\n * @param params - incoming data validated against the current `shopId`\n * @param record - record used to validate or set the `shopId` on\n * @param {Object} options - Additional options for cross-shop or cross-customer validation\n * @param {string} options.shopBelongsToField - Specifies which related model is used for cross-shop validation.\n * @param {string} options.customerBelongsToField - Specifies which related model is used for cross-customer validation.\n * @param {boolean} options.enforceCustomerTenancy - Whether or not to enforce customer tenacy. Defaults to true.\n */\nexport async function preventCrossShopDataAccess(\n  params: AnyParams,\n  record: GadgetRecord<any>,\n  options?: { shopBelongsToField?: string; customerBelongsToField?: string; enforceCustomerTenancy?: boolean }\n): Promise<void> {\n  const enforceCustomerTenancy = options?.enforceCustomerTenancy ?? true;\n  const context = getActionContextFromLocalStorage();\n\n  if (context.type != \"effect\") {\n    throw new Error(\"Can't prevent cross shop data access outside of an action effect\");\n  }\n  if (!params) {\n    throw new Error(\n      \"The `params` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  if (!record) {\n    throw new Error(\n      \"The `record` parameter is required in preventCrossShopDataAccess(params, record, options?: { shopBelongsToField: string })\"\n    );\n  }\n  const model = context.model;\n  const appTenancy = context[AppTenancyKey];\n  const shopBelongsToField = options?.shopBelongsToField;\n  const customerBelongsToField = options?.customerBelongsToField;\n\n  // if there's no tenancy let's continue\n  if (appTenancy?.shopify?.shopId === undefined) {\n    return;\n  }\n  // if this effect is not run in the context of a model then it does not apply\n  if (!model) {\n    return;\n  }\n\n  const shopId = String(appTenancy.shopify.shopId);\n  const customerId = appTenancy.shopify.customerId ? String(appTenancy.shopify.customerId) : undefined;\n\n  const input = params[model.apiIdentifier];\n  validateBelongsToLink({\n    input,\n    record,\n    params,\n    tenantId: shopId,\n    model,\n    tenantModelKey: ShopifyShopKey,\n    tenantBelongsToField: shopBelongsToField,\n    tenantType: TenantType.Shop,\n    tenantName: \"Shopify\",\n  });\n\n  if (customerId && enforceCustomerTenancy) {\n    validateBelongsToLink({\n      input,\n      record,\n      params,\n      tenantId: customerId,\n      model,\n      tenantModelKey: ShopifyCustomerKey,\n      tenantBelongsToField: customerBelongsToField,\n      tenantType: TenantType.Customer,\n      tenantName: \"Shopify\",\n    });\n  }\n}\n\nexport function validShopsFilter(\n  shopModelFiles: { apiIdentifier: string }[],\n  params: { skipInvalidPlans?: boolean; additionalFilters?: FilterElement[] }\n): FilterElement[] {\n  const filter: FilterElement[] = [{ state: { inState: \"created.installed\" } }, ...(params.additionalFilters ?? [])];\n\n  const planNameField = shopModelFiles.find((f) => f.apiIdentifier === \"planName\");\n  const planDisplayNameField = shopModelFiles.find((f) => f.apiIdentifier === \"planDisplayName\");\n\n  if (params.skipInvalidPlans && (planNameField || planDisplayNameField)) {\n    const planCondition = {\n      AND: [] as FilterElement[],\n    };\n\n    if (planNameField) {\n      planCondition.AND.push({\n        OR: [{ planName: { isSet: true, notIn: invalidPlanNames } }, { planName: { isSet: false } }],\n      });\n    }\n\n    if (planDisplayNameField) {\n      planCondition.AND.push({\n        OR: [{ planDisplayName: { isSet: true, notIn: invalidPlanDisplayNames } }, { planDisplayName: { isSet: false } }],\n      });\n    }\n\n    filter.push(planCondition);\n  }\n\n  return filter;\n}\n\n/**\n * Syncs Shopify models across all models\n *\n * @param params - list of Shopify app credentials to sync data from\n * @param syncSince - starting point for data sync (default: all time)\n * @param syncSinceBy - field name to use for the syncSince timestamp filter (\"created_at\" or \"updated_at\")\n * @param syncLast - syncs the last N records\n * @param syncLastBy - field name to use for the syncLast timestamp filter (\"created_at\" or \"updated_at\")\n * @param models - list of model names to sync data from\n * @param force - enforces syncswithout checking if they're up to date\n * @param startReason - a string reason stored on the created 'shopifySync' records\n */\nexport async function globalShopifySync(params: {\n  apiKeys: string[];\n  syncSince: string | Date;\n  models: string[];\n  force?: boolean;\n  syncSinceBy?: string;\n  syncLast?: number;\n  syncLastBy?: string;\n  startReason?: string;\n}): Promise<void> {\n  const context = getCurrentContext();\n  const effectAPIs = assert(context.effectAPIs, \"effect apis is missing from the current context\");\n  const api = assert(context.api, \"api client is missing from the current context\");\n\n  const { apiKeys, syncSince, models, force, syncSinceBy, syncLast, syncLastBy, startReason } = params;\n\n  if (!apiKeys || apiKeys.length === 0) {\n    throw new InvalidActionInputError(\"missing at least 1 api key\");\n  }\n\n  const {\n    shopModelIdentifier,\n    installedViaKeyFieldIdentifier,\n    shopifySyncModelApiIdentifier,\n    runShopifySyncAction,\n    accessTokenIdentifier,\n    forceFieldIdentifier,\n  } = await effectAPIs.getSyncIdentifiers();\n  const shopModel = getModelByApiIdentifier(shopModelIdentifier);\n  const manager = internalModelManagerForModel(api, shopModelIdentifier, []);\n\n  const pageSize = 250;\n  let pageInfo: { first?: number; endCursor?: string; hasNextPage: boolean } = { first: pageSize, hasNextPage: true };\n  const results: { id: string; domain: string; state: Record<string, any>; [key: string]: any }[] = [];\n\n  const filter = validShopsFilter(\n    Object.values(shopModel.fields).map((f) => ({ apiIdentifier: f.apiIdentifier })),\n    {\n      additionalFilters: [{ [installedViaKeyFieldIdentifier]: { in: apiKeys } }],\n    }\n  );\n\n  try {\n    while (pageInfo.hasNextPage) {\n      const records = await manager.findMany({\n        filter,\n        first: pageInfo.first,\n        after: pageInfo.endCursor,\n      });\n      results.push(...(records as any[]));\n      pageInfo = records.pagination.pageInfo;\n    }\n  } catch (error) {\n    context.logger.info({ userVisible: true, error, apiKeys }, \"could not get shops for all API keys\");\n    throw error;\n  }\n\n  for (const result of results) {\n    const shopId = result.id;\n    const domain = result.domain ?? result.myshopifyDomain;\n    context.logger.debug({ shopId, domain }, \"syncing shop\");\n\n    // skip the sync if there is no accessToken set or if the state is uninstalled\n    if (context[kGlobals].platformModules.lodash().isEmpty(result[accessTokenIdentifier]) || result.state?.created == \"uninstalled\") {\n      context.logger.info({ shopId, domain }, \"skipping sync for shop without access token or is uninstalled\");\n      continue;\n    }\n\n    try {\n      const shopifySyncModelManager = context[kGlobals].platformModules.lodash().get(api, runShopifySyncAction.dotNotationPath);\n      await shopifySyncModelManager[runShopifySyncAction.apiIdentifier]({\n        [shopifySyncModelApiIdentifier]: {\n          shop: {\n            _link: shopId,\n          },\n          domain,\n          syncSince,\n          syncSinceBy,\n          models,\n          syncLast,\n          syncLastBy,\n          ...(forceFieldIdentifier ? { force } : undefined),\n        },\n        startReason,\n      });\n    } catch (error) {\n      // log that the sync could not be started for the shop but continue\n      Globals.logger.warn({ userVisible: true, error, shop: result }, \"couldn't start sync for shop\");\n    }\n  }\n}\n\nconst enum TenantType {\n  Shop = \"shop\",\n  Customer = \"customer\",\n}\n\nconst shopifyModelKey = (modelName: string): string => {\n  const modelKey = modelName.replaceAll(\" \", \"\");\n  return `DataModel-Shopify-${modelKey}`;\n};\n\n/**\n * Updates the state of a `bulkOperation` record from Shopify when the operation completes.\n *\n * @param record - the `bulkOperation` record updated\n */\nexport async function finishBulkOperation(record: GadgetRecord<any>): Promise<void> {\n  if (!record?.id) {\n    Globals.logger.warn(`Expected bulk operation record to be present for action`);\n    return;\n  }\n\n  const context = getActionContextFromLocalStorage();\n  const shopifyAPI = await (context.connections as Record<string, any>).shopify.forShopId(record.shopId);\n  if (!shopifyAPI) {\n    Globals.logger.error(`Could not instantiate Shopify client for shop ID ${record.shopId}`);\n    return;\n  }\n  const bulkOperation = (\n    await shopifyAPI.graphql(\n      `query {\n        node(id: \"${ShopifyBulkOperationGIDForId(record.id)}\") {\n          ... on BulkOperation {\n            id\n            status\n            errorCode\n            createdAt\n            completedAt\n            objectCount\n            fileSize\n            url\n            type\n            partialDataUrl\n            rootObjectCount\n          }\n        }\n      }`,\n      {}\n    )\n  ).node;\n  // normalize the mixed upper/lowercase (GraphQL/REST) to lowercase\n  const { status, errorCode, type } = bulkOperation;\n  Object.assign(record, {\n    ...bulkOperation,\n    status: status?.toLowerCase(),\n    errorCode: errorCode?.toLowerCase(),\n    type: type?.toLowerCase(),\n    id: record.id,\n  });\n}\n\nconst ShopifyShopKey: string = shopifyModelKey(\"Shop\");\nconst ShopifyCustomerKey: string = shopifyModelKey(\"Customer\");\n\nconst ShopifyBulkOperationGIDForId = (id: string) => `gid://shopify/BulkOperation/${id}`;\n\ntype TemplateFile = {\n  filename: string;\n};\n\ntype GetThemeFilesResponse = {\n  themes: {\n    nodes: {\n      id: string;\n      files: {\n        nodes: TemplateFile[];\n        pageInfo: {\n          endCursor: string | null;\n          hasNextPage: boolean;\n        };\n      };\n    }[];\n  };\n};\n\ntype ThemeVersion = \"v1\" | \"v2\";\n\n/**\n * Determines the theme version (v1/liquid or v2/JSON) for Shopify template files by fetching the template files from the store and analyzing file extensions.\n * Note that `read_themes` Shopify API scope is required to fetch the files.\n *\n * @param {Shopify} shopify - The Shopify client to determine the theme version for.\n * @param {string[]} pageTypes - An optional array of template page type names to include in the analysis. The values should be Shopify page types. (https://shopify.dev/docs/api/liquid/objects/request#request-page_type)\n * @returns {Promise<{pageType: string; filename: string; version: ThemeVersion}[]>} An array of objects containing the page type name (e.g. \"index\", \"product\", \"customers/activate_account\"), filename, and theme version (v1/liquid or v2/JSONd)\n */\nexport const determineShopThemeVersion = async (\n  shopify: {\n    graphql: (data: string, variables?: any) => Promise<any>;\n  },\n  pageTypes?: string[]\n): Promise<\n  {\n    pageType: string;\n    filename: string;\n    version: ThemeVersion;\n  }[]\n> => {\n  const filenames: string[] = pageTypes?.flatMap((pageType) => [`templates/${pageType}.json`, `templates/${pageType}.liquid`]) ?? [];\n  if (filenames.length === 0) {\n    filenames.push(\"templates/*.json\", \"templates/*.liquid\");\n  }\n\n  const templateFiles: TemplateFile[] = [];\n  let previousFileCursor: string | null = null;\n  let hasNextPage = true;\n\n  // Get all template files from the theme\n  while (hasNextPage) {\n    const response: GetThemeFilesResponse = await shopify.graphql(\n      `\n      query GetThemeFiles ($filenames: [String!]!, $fileCursor: String) {\n        themes(first: 1, roles: [MAIN]) {\n          nodes {\n            files(first: 250, filenames: $filenames, after: $fileCursor) {\n              nodes {\n                filename\n              }\n              pageInfo {\n                endCursor\n                hasNextPage\n              }\n            }\n          }\n        }\n      }`,\n      {\n        filenames,\n        fileCursor: previousFileCursor,\n      }\n    );\n\n    const theme = response.themes.nodes[0];\n    if (!theme) {\n      throw new Error(\"Theme not found\");\n    }\n\n    templateFiles.push(...theme.files.nodes);\n\n    if (theme.files.pageInfo.hasNextPage) {\n      previousFileCursor = theme.files.pageInfo.endCursor;\n      hasNextPage = theme.files.pageInfo.hasNextPage;\n    } else {\n      hasNextPage = false;\n    }\n  }\n\n  return templateFiles.map((file) => {\n    const filename = file.filename;\n    const fileExtension = path.extname(filename);\n    const version = fileExtension === \".json\" ? \"v2\" : \"v1\";\n    const filePathWithoutTemplatesDirectory = filename.replace(\"templates/\", \"\");\n\n    /**\n     * Get a page type for the template. For example:\n     * - templates/product.json -> product\n     * - templates/customers/activate_account.liquid -> customers/activate_account\n     */\n    const pageType = path.join(\n      path.dirname(filePathWithoutTemplatesDirectory),\n      path.basename(filePathWithoutTemplatesDirectory, fileExtension)\n    );\n\n    return {\n      pageType,\n      filename,\n      version,\n    };\n  });\n};\n"],"names":["ShopifyBulkOperationState","ShopifySellingPlanGroupProductState","ShopifySellingPlanGroupProductVariantState","ShopifyShopState","ShopifySyncState","abortSync","determineShopThemeVersion","finishBulkOperation","globalShopifySync","preventCrossShopDataAccess","shopifySync","validShopsFilter","Installed","created","Uninstalled","Created","Running","Completed","Errored","Canceled","Failed","Expired","Started","Deleted","params","record","context","getActionContextFromLocalStorage","effectAPIs","syncRecord","assert","shopId","syncSinceBy","InvalidActionInputError","syncLastBy","models","Array","isArray","every","m","sync","id","toString","syncSince","force","startReason","syncLast","error","logger","connectionSyncId","syncId","errorMessage","info","userVisible","options","enforceCustomerTenancy","type","Error","model","appTenancy","AppTenancyKey","shopBelongsToField","customerBelongsToField","shopify","undefined","String","customerId","input","apiIdentifier","validateBelongsToLink","tenantId","tenantModelKey","ShopifyShopKey","tenantBelongsToField","tenantType","tenantName","ShopifyCustomerKey","shopModelFiles","filter","state","inState","additionalFilters","planNameField","find","f","planDisplayNameField","skipInvalidPlans","planCondition","AND","push","OR","planName","isSet","notIn","invalidPlanNames","planDisplayName","invalidPlanDisplayNames","getCurrentContext","api","apiKeys","length","shopModelIdentifier","installedViaKeyFieldIdentifier","shopifySyncModelApiIdentifier","runShopifySyncAction","accessTokenIdentifier","forceFieldIdentifier","getSyncIdentifiers","shopModel","getModelByApiIdentifier","manager","internalModelManagerForModel","pageSize","pageInfo","first","hasNextPage","results","Object","values","fields","map","in","records","findMany","after","endCursor","pagination","result","domain","myshopifyDomain","debug","kGlobals","platformModules","lodash","isEmpty","shopifySyncModelManager","get","dotNotationPath","shop","_link","Globals","warn","shopifyModelKey","modelName","modelKey","replaceAll","shopifyAPI","connections","forShopId","bulkOperation","graphql","ShopifyBulkOperationGIDForId","node","status","errorCode","assign","toLowerCase","pageTypes","filenames","flatMap","pageType","templateFiles","previousFileCursor","response","fileCursor","theme","themes","nodes","files","file","filename","fileExtension","path","extname","version","filePathWithoutTemplatesDirectory","replace","join","dirname","basename"],"mappings":"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"}